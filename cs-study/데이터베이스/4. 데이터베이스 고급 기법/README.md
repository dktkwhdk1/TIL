# [SECTION 1] 트랜잭션

### 1️⃣ 트랜잭션(Transaction)의 정의

**트랜잭션은 데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜 주는 일련의 논리적인 연산 집합을 의미**한다.

- 데이터베이스에서 일어나는 연산의 집합이다.
- 하나의 논리적 기능을 수행하기 위한 작업의 단위이다.
- 데이터베이스의 상태를 하나의 일관된 상태에서 다른 일관된 상태로 변환시킨다.
- 병행 제어 및 회복 작업의 논리적 작업 단위이다.
- 하나의 트랜잭션은 완료(Commit)되거나 복귀(Rollback)되어야 한다.
  - 은행에서 입금을 하면 성공을 하던가 실패를 해야지 중간에 멈춰있는건 안된다. 돈을 뺐는데 계좌의 잔고는 남아있고 이러한 형태는 나타나지 않는다.

❗️일례로 포털 사이트 로그인을 할 때 DB에서 아이디와 비밀번호를 받아서 정상적으로 로그인 시켜주는 하나의 행위도 트랜잭션이다.

❗️은행 계좌에 입금, 출금도 각각 하나의 트랜잭션이다.

❗️즉, 어떠한 DB든 하나의 액션이 일어났을 때의 상태를 트랜잭션이라 한다.

❗️입력과 출력이 동시에 일어나는 것이 아니고, 입력 자체도 트랜잭션이고 출력 자체도 트랜잭션이라는 것이다.

<br/>

### 2️⃣ 트랜잭션의 특성(Transaction Property) - ACID❗️

**1) ⭐️ 원자성(Atomicity) ⭐️**

- 트랜잭션의 가장 중요한 성질이다.
- 트랜잭션이라는 것은 연산의 집단을 의미하지만, 논리적으로는 **하나**라는 의미이다.
- 트랜잭션은 분리해서 일할 수 없고, 따라서 일부의 완료라는 것은 존재하지 않는다.
- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지(All) 아니면 전혀 반영되지 않아야(Nothing) 한다는 성질이다.

**2) 일관성(Consistency)**

- 고정 요소는 트랜잭션 실행 전과 후가 같아야 한다는 성질이다.
- 트랜잭션이 실행되고 나서도 데이터베이스의 상태는 무결성이 유지되고 모순되지 말아야 된다는 성질이다.

\*\* 무결성 : 정보에 결점이 없도록 유지하는 성질

**3) 독립성(Isolation) = 격리성**

- 트랜잭션이 실행되는 중간에는 다른 트랜잭션 연산이 침범하지 못하는 성질이다.
- 같은 자원에 대해 여러 개의 트랜잭션이 동시에 사용할 수 없다는 성질이다.
- 입력 트랜잭션과 출력 트랜잭션, 입출금이 동시에 일어날 수 없다.

**4) 영속성(Durability) = 지속성 = 계속성**

- 트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질이다.
- 트랜잭션이 성공적인 완료를 응답했다면 트랜잭션 완료의 효과는 지속되어야 한다는 성질이다.

<br/>

### 3️⃣ 트랜잭션의 상태

![Untitled](https://user-images.githubusercontent.com/44192757/112101998-ec6b5f80-8bea-11eb-82ff-1eac28012dac.png)

- **활동(Active)** : 트랜잭션이 실행 중인 상태를 의미한다.
- **부분 완료(Partially Committed)** : 트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행한 결과를 적용하기 직전의 상태를 의미한다.
  - ex) 은행 ATM에서 카드 삽입, 비밀번호 입력 등의 중간 과정을 부분 완료라고 한다. 그 중 하나가 완료된 것이 부분 완료가 된 것이다.
- **완료(Committed)** : 트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태를 의미한다.
- **실패(Failed)** : 트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태를 의미한다.
- **철회(Aborted)** : 트랜잭션 실행이 실패하여 복귀된 상태를 의미한다.

<br/>

### 4️⃣ 트랜잭션의 연산

- **COMMIT(완료)** : 트랜잭션 실행이 성공적으로 종료(DB에 적용했다는 얘기이다)되었음을 알리는 연산자로 데이터 아이템의 값들은 영속성이 보장되며, 데이터베이스의 상태가 일관성 있는 상태로 변화된 상태를 의미한다.
- **ROLLBACK(복귀)** : 트랜잭션 실행이 실패하였음을 알리는 연산자로 트랜잭션이 수행한 결과를 원래의 상태로 복귀시켜야 하는 상태를 의미한다.

<br/><br/>

## [SECTION 2] 보안 및 무결성

### 1️⃣ 보안(Security) 및 무결성(Integrity)의 개념

**1) 보안(Security)**

- 데이터베이스로 구축되어진 모든 자료를 외부의 부적절한 접근으로부터 보호하는 것을 의미한다.
- 데이터베이스에 접근 권한이 부여되어 있지 않은 요소로부터 변경, 파괴, 획득되는 행위를 방지하는 것을 의미한다.
- 보안을 위한 사용자들의 권한 부여는 관리자의 정책에 따라 결정된다.
- 보안을 위한 데이터 단위와 각 사용자의 접근 권한은 다양한 단위로 부여된다.

**2) 무결성(Integrity)**

- 무결성은 데이터베이스에 저장된 데이터 값이 정확한 정보를 나타내도록 유지하는 정확성(Correctness)이나 정밀성(Accuracy)을 의미한다.
- 데이터베이스를 정의하고 나서 최초로 데이터를 적재한 상태에서는 데이터가 정확하게 들어있다고 가정한 후, 이 상태에서 허가된 사용자가 발생시킨 트랜잭션에 의한 갱신이 이루어졌을 때 데이터베이스에 있는 데이터가 정확한 데이터를 유지하도록 하는 것을 의미한다.

<br/>

### 2️⃣ 권한 부여 방법

**1) 뷰(View)를 이용한 권한 부여**

뷰는 기본 테이블로부터 유도하여 만들어지는 가상 테이블이다. 따라서 특별한 권한 부여 방법이라고 보기보다는 기본 테이블로부터 제공하고 싶은 일부의 내용만을 뷰 테이블로 만들어 주면, 곧 그 뷰 테이블을 사용하는 사용자는 그것에 대한 사용 권한만이 부여되는 것을 의미한다.

**2) GRANT 명령문을 이용한 권한 부여**

```sql
GRANT 권한 종류 ON 데이터 개체 TO {사용자 | PUBLIC} [WITH GRANT OPTION];

여기서 WITH GRANT OPTION 이 구문이 기술되면 권한을 부여받은 사용자가
그 권한을 다른 사용자에게 또 다시 부여할 수 있다.

데이터 개체 : 권한 부여 대상이 되는 데이터 그룹을 의미
```

데이터 개체에 대한 생성자만이 모든 권한을 소유하고 권한을 부여받는 사용자는 부여받은 권한만을 행사하게 된다.

**3) REVOKE 명령문에 의한 권한 해제**

```sql
REVOKE 권한 종류 [GRANT OPTION FOR] ON 데이터 개체 FROM 사용자
      {CASCADE | RESTRICT};
```

- GRANT OPTION FOR : 다른 사용자에게 부여할 수 있게 한 권한을 취소하는 옵션이다.
- CASCADE 및 RESTRICT : CASCADE는 임의의 사용자 권한을 취소하게 되면 그 사용자가 다른 사용자에게 제공했던 권한까지도 자동으로 해제되며, RESTRICT는 다른 사용자에게 권한을 부여한 것이 있다면 권한 해제 명령 자체가 취소된다.

<br/>

### 3️⃣ 암호화 기법

암호화되기 이전의 데이터를 플레인 텍스트(Plain Text)라고 부르고 암호화된 이후의 데이터를 사이퍼 텍스트(Cipher Text)라고 부르며 암호화 기법에는 아래와 같은 방법들이 있다.

**1) 공통키 방식(대칭형 암호화 알고리즘)**

네트워크상에서 송신자가 암호키로 암호화하여 보내면 수신자가 동일한 암호키로 복호화하는 방식으로 DES, IDEA, RC2 등이 있다.

- **대체 기법** : 어떤 알고리즘이나 추측에 의해서 알아맞힐 수 없는 특수한 암호키를 가지고 데이터를 암호화했다가 자료 이용 시 같은 암호키를 이용하여 해독하는 기법이다.
- **DES(Data Encryption Standard)** : 미국 상무국 표준 협회에서 공모하여 사용하고 있는 암호화 기법으로, 56비트의 암호/복호키를 이용하여 64비트 평문을 암호화 또는복호화 하는 기법이다.

**2) 공개키(Public-Key) 방식(비대칭형 암호화 알고리즘)**

데이터를 암호문으로 변환할 때의 암호키와 암호문을 평문으로 변환시킬 때의 복호키가 서로 다르며 암호화하는 암호키는 공개하고 복호키는 비밀로 해 데이터의 송수신 시 보안을 유지하는 방법으로 RSA 기법이 있다.

<br/>

### 4️⃣ 무결성 규정 종류

**❗️일전에 정리했지만 한 번 더 보자(CHAPTER3→SECTION1→3) ❗️**

**1) 도메인 무결성 규정(Domain Integrity Rule)**

가장 기본적인 무결성 규정으로 데이터베이스 릴레이션(테이블)에서 주어진 속성(Attribute)으로 입력되는 모든 값은 그 속성으로 정의되거나 제약된 도메인 영역에 있어야 된다는 규정을 의미한다.

**2) 개체 무결성 규정(Entity Integrity Rule)**

주어진 릴레이션에 튜플을 삽입, 삭제, 갱신하고 나서 그 전후의 관계가 의미적으로 이상이 없는가를 규정하는 것으로 주어진 릴레이션에 기본키(Primary Key)를 선언하고 기본키로 NULL 값을 허용하지 않은 상태에서 기본키에 따라 릴레이션에 접근하여 연산함으로써 유지되는 무결성을 말한다. 즉, 하나의 개체 릴레이션(테이블)에서는 중복된 튜플이 존재해서는 안 된다는 제약을 의미하는 것이다.

**3) 참조 무결성 규정(Referential Integrity Rule)**

릴레이션에 있는 튜플 정보가 다른 릴레이션에 있는 튜플 정보와 비교하여 관계성이 있으며 관계되는 정보의 정확성을 유지하는가를 규정하는 것으로 외래키(Foreign Key)에 의해 유지된다.

<br/>

### 5️⃣ 트리거(Trigger)

선언적 형태의 무결성 규정은 무결성 규정 위반 시 단지 해당 트랜잭션을 취소시키는 것이다. 그러나 취소 이외의 조치를 명세하고자 하는 경우는 트리거를 사용한다. 트리거는 트리거 조건식에 따라 메시지를 전달하거나 데이터를 자동으로 갱신할 수 있도록 함수나 명령문을 수행하게 제약을 가하는 것을 의미한다.

```sql
DEFINE TRIGGER 트리거 이름 ON 트리거 조건식 : 해야 할 명령문
```

<br/><br/>

## [SECTION 3] 병행 제어

여러 사용자가 동시에 데이터베이스를 액세스하게 되면 많은 트랜잭션이 동시에 발생하게 된다. 이러한 여러 트랜잭션이 일관성을 가지고 제대로 처리되기 위해서는 직렬성이 보장되어야 하는데 이러한 직렬성 보장을 위한 일련의 방법(Aborting(중지), Delaying(지연))을 병행 제어라 한다.

\*\* 직렬성 : 트랜잭션을 순서적으로 실행하는 것과 인터리브(Interleave) 실행이 포함되어 병행 실행시키는 결과가 정확히 일치하는 경우를 직렬 가능성이라 한다.

<br/>

### 1️⃣ 병행 제어(Concurrency Control)의 목적

- 데이터베이스의 공유도를 최대화한다.
- 사용자에 대한 응답 시간을 최소화한다.
- 시스템의 활용도를 최대화한다.
- 데이터베이스의 일관성을 유지한다.

<br/>

### 2️⃣ 제약 없는 병행 처리(Concurrency Processing) 시 문제점

- **분실된 갱신(Lost Update)** : 두 개의 트랜잭션이 같은 데이터에 대해서 동시에 갱신 작업을 하면 하나의 갱신 작업이 분실되는 경우
- **모순성(Inconsistency) = 불일치** : 한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되면, 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 결과하고 일치하지 않는 상태가 되어 데이터베이스의 일관성을 해치는 경우
- **연쇄 복귀(Cascading Rollback)** : 같은 자원을 사용하는 두 개의 트랜잭션 중, 한 개의 트랜잭션이 성공적으로 일을 수행하였다 하더라도 다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두가 복귀되는 현상
- **비완료 의존성(Uncommitted Dependency)** : 한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기 전에 다른 트랜잭션이 이 트랜잭션의 수행 결과를 참조하는 현상

<br/>

### 3️⃣ 로킹(Locking)

직렬성을 보장하기 위해 하나의 트랜잭션이 어떤 데이터에 대해서 액세스하는 동안 또 다른 트랜잭션이 이 데이터에 대해 액세스하기 위해서는 로크(Lock)를 소유하고 있어야만 가능하도록 하는 방법으로 언제 로크를 소유하고 해제하는가 하는 로킹 규칙을 정해놓고 해결하는 방법이다.

\*\* 로크(Lock) : 데이터베이스를 관리할 경우 하나의 트랜잭션에 사용되는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 행위이다.

**1) 로킹 기법**

👉 공유 형태로 로킹하는 방법

임의의 트랜잭션이 발생했을 때 트랜잭션이 임의의 데이터에 대해서 읽기 권한은 가지나 쓰기 권한은 갖지 못하게 하는 방법이다.

👉 독점 형태(배타)로 로킹하는 방법

임의의 트랜잭션이 발생했을 때 트랜잭션이 데이터에 대해서 읽기와 쓰기 권한 모두를 갖게 하는 방법이다.

\*\* 병행 제어 기법의 종류

- 로킹(locking) : 자원 이용에 대하여 상호배제 기능을 이용하는 기법
- 타임스탬프 순서(Time Stamp Ordering) : 시스템에 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법
- 검증 기법(Validation) : 읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성을 보장하는 기법
- 다중버전 기법(Multi Version) : 갱신 연산 때마다 새로운 버전을 만들어 병렬수행을 제어하는 기법

**2) 로킹 단위(Locking Granularity)**

로킹 단위는 로킹 대상이 되는 객체의 크기를 의미하는 것으로 주요 단위로는 데이터베이스, DBSPACE, 파일 레코드, 필드, 테이블, 페이지, 행 등이 있다.

**로킹 단위를 작게 했을 때**

병행성 수준은 뛰어나지만 관리가 어렵다. 즉, 데이터베이스이 자료를 많은 수의 작은 단위로 쪼개어 여러 사용자가 사용하게 되면 데이터의 공유도는 증가하지만 로크(Lock) 수가 많아 병행 제어 기법이 복잡하고 관리가 어렵게 된다.

**로킹 단위를 크게 했을 때**

병행성 수준은 낮아지지만 관리가 쉽다. 즉, 데이터베이스를의 자료를 몇 개의 큰 단위로 묶어 사용하게 되면 로크(Lock)의 수가 적어 병행제어 기법이 간단하여 관리는 쉽지만 데이터의 공유도가 현저히 떨어지게 된다.

\*\* 교착상태(Deadlock) : 로킹 규약은 직렬성을 보장할 수는 있으나 교착상태가 발생할 수 있다는 문제점이 있다. 교착상태라는 것은 두 개 이상의 트랜잭션이 있을 때 트랜잭션들이 서로 실행이 완료되기를 무한정 기다리는 것을 의미한다.

<br/><br/>

## [SECTION 4] 분산 데이터베이스 시스템

### 1️⃣ 분산 데이터베이스 시스템의 목적

**분산 데이터베이스 시스템의 목적은 투명성(Transparency) 보장**에 있다. 분산 데이터베이스의 DBMS가 가져야 할 투명성에는 다음과 같은 것들이 있다.

- **위치 투명성(Location Transparency)** : 사용자가 물리적으로 저장되어 있는 곳을 알 필요 없이 논리적인 입장에서 데이터가 모두 자신의 사이트에 있는 것처럼 처리하는 특성이다.
- **중복 투명성(Replication Transparency)** : 접근 횟수가 많은 데이터에 대해서는 각 사이트마다 데이터를 중복시켜 놓고 트랜잭션이 데이터의 중복 개수나 중복 사실을 모르고도 데이터 처리가 가능하게 하여 병목 현상을 방지하는 특성이다.
- **병행 투명성(Concurrency Transparency)** : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실행되더라도 트랜잭션의 결과에 이상이 없게 하는 특성이다.
- **장애 투명성(Failure Transparency)** : 일부의 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션이 수행될 수 있는 특성이다.

\*\* 투명성(Transparency) : 투명성이란 자원의 존재 위치와는 무관하게 시스템의 모든 파일에 대하여 사용자가 동일한 방법으로 접근할 수 있도록 하는 것으로 사용의 단순성, 용이성 등을 위해 어떤 객체의 특성 중 일부가 사용자에게 숨겨져 그 존재를 인식하지 못하게 한 것을 말한다.

<br/>

### 2️⃣ 분산 데이터베이스 시스템의 장단점

**1) 장점**

- 분산되어 있는 데이터를 효과적으로 이용 및 처리할 수 있으므로 공용성과 가용성이 뛰어나다.
- 지역 업무에 대한 자치성이 높다.
- 새로운 응용에 대한 문제가 발생했을 때 추가와 폐쇄가 용이하므로 점증적 시스템 확장이 용이하고 적응성과 확장성이 뛰어나다.
- 시스템에 대한 장애가 발생했을 때 다원적으로 변경이 용이하므로 신뢰성을 증진할 수 있다.
- 각 지역의 특색에 맞는 자원을 이용하여 하드웨어나 소프트웨어를 구축할 수 있으므로 융통성이 뛰어나다.

**2) 단점**

- 필요로 하는 장비가 많으므로 구축이 복잡하며 구축 비용이 많이 든다.
- 소프트웨어 개발이 복잡하고 개발 비용이 비싸다.
- 통신망에 따른 제약사항이 있다.

\*\* 분산 데이터베이스 설계 시 고려사항

- 작업 부하(Work Load)의 노드별 분산 정책
- 지역의 자치성 보장 정책
- 데이터의 일관성 정책
- 분산 노드 간 데이터의 중복성 감소와 가용성 증대 정책
